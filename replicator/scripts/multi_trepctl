#!/usr/bin/env ruby

require "#{File.dirname(__FILE__)}/../../cluster-home/lib/ruby/tungsten"

class TungstenMultipleTrepctl
  include TungstenScript
  
  def main
    begin
      # Collect records from all trepctl locations filtering out
      # replication services that don't match --roles or --services if given
      records = load_services({
        "role" => opt(:limit_roles),
        "serviceName" => opt(:limit_services)
      })
      
      # Sort records by the fields passed in on --sort-by
      records = sort_records(records, opt(:sort_by))
      
      # Output the matching records
      output_records(records, opt(:fields), opt(:format))
    rescue => e
      raise e
    end
  end
  
  # Run the command in parallel on each trepctl location collecting the output
  def collect_trepctl_output(command)
    pids = []
    results = {}
    
    # Run the trepctl services -full -json command on each matching
    # location and wait for the output
    @trepctl_locations.each{
      |loc_id,loc|
      
      results[loc_id] = Tempfile.new('ssh')
      pids << fork {
        options = []
        if loc.has_key?(:port)
          options << "-port #{loc[:port]}"
        end
        
        results[loc_id].write(TU.ssh_result("#{loc[:directory]}/tungsten/tungsten-replicator/bin/trepctl #{options.join(" ")} #{command}", loc[:host], TI.user()))
      }
    }
    # Wait for each thread to finish   
    pids.each{|pid| Process.waitpid(pid) }
    
    results.each{
      |loc_id, file|
      file.rewind()
      results[loc_id] = file.read()
    }
    
    results
  end
  
  # Load the status for all matching replication services and return them
  # as an array
  def load_services(filters = {})
    services = []
    filters = prepare_filters(filters)
    results = collect_trepctl_output("services -full -json")
    
    # Parse the JSON output from each return value and add matching
    # replication services to the services array
    results.each{
      |loc_id, output|
      host_trepctl_services = JSON.parse(output)
      
      unless host_trepctl_services.instance_of?(Array)
        raise "Unable to parse the response from #{host}:#{dir}"
      end
      
      host_trepctl_services.each{
        |svc|
      
        # Only add it to the final array if it matches the filters
        if matches_filters?(svc, filters) == true
          services << svc.merge({:loc_id => loc_id})
        end
      }
    }
    
    services
  end
  
  # Turn each filter value into an array for evaluation
  def prepare_filters(filters = {})
    filters.each_key{
      |key|
      if filters[key].is_a?(String)
        filters[key] = filters[key].split(",")
      end
    }
    
    filters
  end
  
  def matches_filters?(record, filters = {})
    matches_filters = true
    filters.each{
      |key,values|
      if values == nil
        next
      end
      
      if values.is_a?(Array)
        unless values.include?(record[key])
          matches_filters = false
        end
      else
        unless values == record[key]
          matches_filters = false
        end
      end
    }
    
    matches_filters
  end
  
  def output_records(records, fields, format)
    if fields.is_a?(String)
      fields = fields.split(",")
    end
    
    if fields.size() == 0
      raise "Unable to print output because no fields have been requested"
    end
    
    if format == "info"
      table_rows = []
      
      unless opt(:hide_headers) == true
        table_rows << fields.dup()
      end
      
      # Display the fields from each record as a table
      records.each{|rec|
        to_display = []
        fields.each{|field| to_display << rec[field]}
        
        table_rows << to_display.dup()
      }
      output_table(table_rows)
    elsif format == "tab"
      # Display the fields from each record as tab-delmited lines
      unless opt(:hide_headers) == true
        puts fields.join("\t")
      end
      
      records.each{|rec|
        to_display = []
        fields.each{|field| to_display << rec[field]}
        puts to_display.join("\t")
      }
    elsif format == "list"
      # Collect the first field from each record and display on a single line
      to_display = []
      records.each{|rec| to_display << rec[fields[0]] }
      puts to_display.uniq().join(",")
    elsif format == "name"
      # Display the first field from each record on individual lines
      to_display = []
      records.each{|rec| to_display << rec[fields[0]] }
      puts to_display.uniq().join("\n")
    elsif format == "json"
      # Display the fields from each record as a JSON array of hashes
      puts JSON.pretty_generate(records.map{|rec|
        to_display = {}
        fields.each{|field| to_display[field] = rec[field]}
        to_display
      })
    end
  end
  
  def output_table(table_rows)
    fields_max_length = []
    
    # Determine the maximum length for each column
    table_rows.each{|row|
      row.each_index{|idx|
        length = row[idx].to_s().length()
        
        if fields_max_length[idx] == nil || fields_max_length[idx] < length
          fields_max_length[idx] = length
        end
      }
    }
    
    # Print a line for each row
    table_rows.each{|row|
      row.each_index{|idx|
        if (row[idx] =~ /^[\d]+(\.[\d]+){0,1}$/) != nil
          flag = ""
        else
          flag = "-"
        end
        format = "| %#{flag}#{fields_max_length[idx]}s "
        printf(format, row[idx])
      }
      print "|\n"
    }
  end
  
  def sort_records(records, sort_keys)
    if sort_keys.is_a?(String)
      sort_keys = sort_keys.split(",")
    end
    
    # Create a sort index for each record based on sort_keys
    records.each{
      |rec|
      sort_values = []
      sort_keys.each{|key| sort_values << rec[key]}
      rec[:sort] = sort_values
    }
    
    records.sort { |a, b| a[:sort] <=> b[:sort] }
  end
  
  def configure
    super()
    description("")

    add_option(:hosts, {
      :on => ["--hosts String", "--host String"],
      :help => "The hosts to check replicators on"
    })
    
    add_option(:directories, {
      :on => ["--directories String", "--dir String"],
      :help => "The Tungsten directories to check"
    })
    
    add_option(:limit_roles, {
      :on => ["--roles String", "--role String"],
      :help => "The replication service roles to limit on"
    })
    
    add_option(:limit_services, {
      :on => ["--services String", "--service String"],
      :help => "The replication service names to limit on"
    })
    
    add_option(:fields, {
      :on => "--fields String",
      :help => "The status fields to display in the output"
    })
    
    add_option(:sort_by, {
      :on => "--sort-by String",
      :default => "host,serviceName",
      :help => "Sort output by these fields"
    })
    
    add_option(:by_service, {
      :on => "--by-service",
      :default => false,
      :help => "Sort output by replication service"
    }) {
      opt(:sort_by, "serviceName,host")
      nil
    }
    
    add_option(:hide_headers, {
      :on => "--hide-headers",
      :default => false,
      :help => "Suppress headers in output",
      :aliases => ["--skip-headers"]
    })
    
    add_option(:format, {
      :on => "--output String",
      :default => "info",
      :help => "Display format for record output (info|tab|list|name|json)"
    })
  end
  
  def validate
    super()
    
    check_hosts = opt(:hosts).to_s().split(",")
    if check_hosts.size() == 0
      check_hosts = [TI.hostname()]
    end
    
    check_directories = []
    opt(:directories).to_s().split(",").each{
      |dir|
      dir_parts = dir.split(":")
      if dir_parts.size() == 1
        check_directories << {
          :directory => dir_parts[0]
        }
      elsif dir_parts.size() == 2
        check_directories << {
          :directory => dir_parts[0],
          :port => dir_parts[1]
        }
      else
        TU.error("Each directory to check must be valid path and include the RMI port.")
      end
    }
    if check_directories.size() == 0
      check_directories = [{
        :directory => TI.root(),
        :port => TI.setting(REPL_RMI_PORT)
      }]
    end
    
    # Identify the combinations of check_hosts and check_directories that
    # actually contain a replicator
    pids = []
    results = []
    idx = 0
    check_hosts.each{
      |host|
      check_directories.each{
        |dir|

        results[idx] = Tempfile.new('tpm')
        pids[idx] = fork {
          begin
            present = TU.ssh_result("test -f #{dir[:directory]}/tungsten/tungsten-replicator/bin/trepctl", host, TI.user())
            results[idx].write(Marshal.dump(dir.merge({:host => host})))
          rescue RemoteCommandError
            TU.debug("Unable to find a replicator at #{host}:#{dir[:directory]}")
          rescue CommandError
            TU.debug("Unable to find a replicator at #{host}:#{dir[:directory]}")
          end
        }
        idx = idx+1
      }
    }
    pids.each{|pid| Process.waitpid(pid) }

    @trepctl_locations = {}
    results.each{
      |file|
      file.rewind()

      begin
        result = Marshal.load(file.read())
        loc_id = TU.to_identifier("#{result[:host]}_#{result[:directory]}")
        @trepctl_locations[loc_id] = result
      rescue TypeError => te
      rescue ArgumentError => ae
      end
    }
    
    if opt(:fields) == nil
      opt(:fields, "host,serviceName,role,state,appliedLastSeqno,appliedLatency")
    end
    
    unless ["info","tab","list","name","json"].include?(opt(:format))
      TU.error("The specified value for --output is invalid. Valid values are info, tab, list, name and json.")
    end
  end
  
  self.new().run()
end