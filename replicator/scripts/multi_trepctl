#!/usr/bin/env ruby

require "#{File.dirname(__FILE__)}/../../cluster-home/lib/ruby/tungsten"

class TungstenMultipleTrepctl
  include TungstenScript
  
  def main
    begin
      args = TU.remaining_arguments
      if args.size() > 0
        raise "Extra commands are not yet implemented"
      end
      
      # Collect records from all trepctl locations filtering out
      # replication services that don't match --roles or --services if given
      records = load_services({
        "role" => opt(:limit_roles),
        "serviceName" => opt(:limit_services)
      })
      
      if args[0] == "backups"
        @command = args.shift()
        raise "The backups command has not been implemented"
      elsif args[0] == "db"
        @command = args.shift()
        raise "The db command has not been implemented"
      elsif args[0] == "masterof"
        @command = args.shift()
        raise "The masterof command has not been implemented"
      elsif args[0] == "sql"
        @command = args.shift()
        @sql_command = args.join(" ")
        raise "The sql command has not been implemented"
      elsif args.size() > 0
        # collect_trepctl_output(args.join(" "))
        raise "This command has not been implemented"
      else
        # Sort records by the fields passed in on --sort-by
        records = sort_records(records, opt(:sort_by))

        # Output the matching records
        output_records(records, opt(:fields), opt(:format))
      end
    rescue => e
      raise e
    end
  end
  
  # Run the command in parallel on each trepctl location collecting the output
  def collect_trepctl_output(command)
    pids = []
    results = {}
    
    # Run the trepctl services -full -json command on each matching
    # location and wait for the output
    @trepctl_locations.each{
      |loc_id,loc|
      
      results[loc_id] = Tempfile.new('ssh')
      pids << fork {
        options = []
        if loc.has_key?(:port)
          options << "-port #{loc[:port]}"
        end
        
        begin
          results[loc_id].write(TU.ssh_result("#{loc[:directory]}/tungsten/tungsten-replicator/bin/trepctl #{options.join(" ")} #{command}", loc[:host], TI.user()))
        rescue RemoteCommandError => rce
          results[loc_id].write(Marshal.dump(rce))
        rescue CommandError => ce
          results[loc_id].write(Marshal.dump(ce))
        end
      }
    }
    # Wait for each thread to finish   
    pids.each{|pid| Process.waitpid(pid) }
    
    results.each{
      |loc_id, file|
      file.rewind()
      results[loc_id] = file.read()
      
      begin
        exception = Marshal.load(results[loc_id])
        if exception.is_a?(CommandError)
          results[loc_id] = exception
        end
      rescue
      end
    }
    
    results
  end
  
  # Load the status for all matching replication services and return them
  # as an array
  def load_services(filters = {})
    services = []
    filters = prepare_filters(filters)
    results = collect_trepctl_output("services -full -json")
    
    # Parse the JSON output from each return value and add matching
    # replication services to the services array
    results.each{
      |loc_id, output|
      host_trepctl_services = JSON.parse(output)
      
      unless host_trepctl_services.instance_of?(Array)
        raise "Unable to parse the response from #{host}:#{dir}"
      end
      
      host_trepctl_services.each{
        |svc|
      
        # Only add it to the final array if it matches the filters
        if matches_filters?(svc, filters) == true
          svc.keys().each{
            |key|
            svc[key.downcase()] = svc[key]
          }
          svc["service"] = svc["servicename"]
          svc["seqno"] = svc["appliedlastseqno"]
          svc["latency"] = svc["appliedlatency"]
          services << svc.merge({:loc_id => loc_id})
        end
      }
    }
    
    services
  end
  
  # Turn each filter value into an array for evaluation
  def prepare_filters(filters = {})
    filters.each_key{
      |key|
      if filters[key].is_a?(String)
        filters[key] = filters[key].split(",")
      end
    }
    
    filters
  end
  
  def matches_filters?(record, filters = {})
    matches_filters = true
    filters.each{
      |key,values|
      if values == nil
        next
      end
      
      if values.is_a?(Array)
        unless values.include?(record[key])
          matches_filters = false
        end
      else
        unless values == record[key]
          matches_filters = false
        end
      end
    }
    
    matches_filters
  end
  
  def output_records(records, fields, format)
    if fields.is_a?(String)
      fields = fields.split(",")
    end
    
    if fields.size() == 0
      raise "Unable to print output because no fields have been requested"
    end
    
    if format == "info"
      output_table(build_table_rows(records, fields, opt(:hide_headers)), fields)
    elsif format == "tab"
      # Display the fields from each record as tab-delimited lines
      build_table_rows(records, fields, opt(:hide_headers)).each{|row|
        puts row.join("\t")
      }
    elsif format == "list"
      is_first = true
      build_table_rows(records, fields, true).each{|row|
        if is_first == false
          print ";"
        end
        print row.join(",")
        is_first = false
      }
    elsif format == "name"
      build_table_rows(records, fields, true).each{|row|
        puts row.join(" ")
      }
    elsif format == "json"
      # Display the fields from each record as a JSON array of hashes
      puts JSON.pretty_generate(records.map{|rec|
        to_display = {}
        fields.each{|field| to_display[field] = rec[field]}
        to_display
      })
    end
  end
  
  def build_table_rows(records, fields, hide_headers)
    table_rows = []
    
    unless hide_headers == true
      table_rows << fields.dup()
    end
    
    # Display the fields from each record as a table
    records.each{|rec|
      to_display = []
      fields.each{|field| to_display << rec[field]}
      
      table_rows << to_display.dup()
    }
    
    table_rows
  end
  
  def output_table(table_rows, fields)
    fields_max_length = []
    
    # Determine the maximum length for each column
    table_rows.each{|row|
      row.each_index{|idx|
        length = row[idx].to_s().length()
        
        if fields_max_length[idx] == nil || fields_max_length[idx] < length
          fields_max_length[idx] = length
        end
      }
    }
    
    float_columns = ["latency", "appliedlatency", "relativelatency", "timeinstateseconds", "uptimeseconds"]
    # Print a line for each row
    table_rows.each{|row|
      row.each_index{|idx|
        if (row[idx] =~ /^(-)?[\d]+(\.[\d]+){0,1}$/) != nil
          if float_columns.include?(fields[idx])
            format = "| %#{fields_max_length[idx]}.3f "
          else
            format = "| %#{fields_max_length[idx]}s "
          end
        else
          format = "| %-#{fields_max_length[idx]}s "
        end
        printf(format, row[idx])
      }
      print "|\n"
    }
  end
  
  def sort_records(records, sort_keys)
    if sort_keys.is_a?(String)
      sort_keys = sort_keys.split(",")
    end
    
    # Create a sort index for each record based on sort_keys
    records.each{
      |rec|
      sort_values = []
      sort_keys.each{|key|
        # Make sure numeric values are sorted as numbers
        if rec[key] =~ /^(-)?[\d]+(\.[\d]+){0,1}$/
          sort_values << rec[key].to_f()
        else
          sort_values << rec[key]
        end
      }
      rec[:sort] = sort_values
    }
    
    records.sort { |a, b| a[:sort] <=> b[:sort] }
  end
  
  def configure
    super()
    description("")

    add_option(:hosts, {
      :on => ["--hosts String", "--host String"],
      :help => "The hosts to check replicators on"
    })
    
    add_option(:paths, {
      :on => ["--paths String", "--path String"],
      :help => "The Tungsten directories to check"
    })
    
    add_option(:limit_roles, {
      :on => ["--roles String", "--role String"],
      :help => "The replication service roles to limit on"
    })
    
    add_option(:limit_services, {
      :on => ["--services String", "--service String"],
      :help => "The replication service names to limit on"
    })
    
    add_option(:fields, {
      :on => "--fields String",
      :help => "The status fields to display in the output"
    })
    
    add_option(:sort_by, {
      :on => "--sort-by String",
      :default => "host,serviceName",
      :help => "Sort output by these fields"
    })
    
    add_option(:by_service, {
      :on => "--by-service",
      :default => false,
      :help => "Sort output by replication service"
    }) {
      opt(:sort_by, "serviceName,host")
      nil
    }
    
    add_option(:hide_headers, {
      :on => "--hide-headers",
      :default => false,
      :help => "Suppress headers in output",
      :aliases => ["--skip-headers"]
    })
    
    add_option(:format, {
      :on => "--output String",
      :default => "info",
      :help => "Display format for record output (info|tab|list|name|json)"
    })
  end
  
  def validate
    super()
    
    check_directories = []
    opt(:paths).to_s().split(",").each{
      |dir|
      dir_parts = dir.split(":")
      if dir_parts.size() == 1
        check_directories << {
          :directory => dir_parts[0]
        }
      elsif dir_parts.size() == 2
        check_directories << {
          :directory => dir_parts[0],
          :port => dir_parts[1]
        }
      else
        TU.error("Each directory to check must be valid path and include the RMI port.")
      end
    }
    if check_directories.size() == 0
      running_replicators = TU.cmd_result("ps -eo args | grep \"Tungsten Replicator\"")
      running_replicators.each{
        |ps|
        match = ps.match(/^([a-zA-Z\/]*)\/releases/)
        unless match == nil
          check_directories << {
            :directory => match[1]
          }
        end
      }
    end
    
    check_hosts = opt(:hosts).to_s().split(",")
    
    if check_hosts.size() == 0
      check_directories.each{
        |dir|
        ds_list = TU.cmd_result("#{dir[:directory]}/tungsten/tools/tpm query dataservices | awk -F \":\" '{print $1}' | tr -d \" \"")
        ds_list.split("\n").each{
          |ds|
          begin
            value_key = "dataservices.#{ds}.dataservice_replication_members"
            host_list_raw = TU.cmd_result("#{dir[:directory]}/tungsten/tools/tpm query values #{value_key}")
            host_list = JSON.parse(host_list_raw)
            check_hosts = check_hosts + host_list[value_key].split(",")
          rescue CommandError
          end
        }
        check_hosts.uniq!()
      }
    end
    
    if check_hosts.size() == 0
      check_hosts = [TI.hostname()]
    end
    
    if check_directories.size() == 0
      check_directories = [{
        :directory => TI.root(),
        :port => TI.setting(REPL_RMI_PORT)
      }]
    end
    
    # Identify the combinations of check_hosts and check_directories that
    # actually contain a replicator
    pids = []
    results = []
    idx = 0
    check_hosts.each{
      |host|
      check_directories.each{
        |dir|

        results[idx] = Tempfile.new('tpm')
        pids[idx] = fork {
          begin
            present = TU.ssh_result("test -f #{dir[:directory]}/tungsten/tungsten-replicator/bin/trepctl", host, TI.user())
            results[idx].write(Marshal.dump(dir.merge({:host => host})))
          rescue RemoteCommandError
            TU.debug("Unable to find a replicator at #{host}:#{dir[:directory]}")
          rescue CommandError
            TU.debug("Unable to find a replicator at #{host}:#{dir[:directory]}")
          end
        }
        idx = idx+1
      }
    }
    pids.each{|pid| Process.waitpid(pid) }

    @trepctl_locations = {}
    results.each{
      |file|
      file.rewind()

      begin
        result = Marshal.load(file.read())
        loc_id = TU.to_identifier("#{result[:host]}_#{result[:directory]}")
        @trepctl_locations[loc_id] = result
      rescue TypeError => te
      rescue ArgumentError => ae
      end
    }
    
    if opt(:fields) == nil
      opt(:fields, "host,serviceName,role,state,appliedLastSeqno,appliedLatency")
    end
    
    opt(:fields, opt(:fields).downcase())
    opt(:sort_by, opt(:sort_by).downcase())
    
    unless ["info","tab","list","name","json"].include?(opt(:format))
      TU.error("The specified value for --output is invalid. Valid values are info, tab, list, name and json.")
    end
  end
  
  self.new().run()
end